// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: table_session.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTableSession = `-- name: CreateTableSession :one
INSERT INTO public.table_session
(id, table_id, number_of_people, status, started_at, expire_at, ended_at)
VALUES($1, $2, $3, 'active', NOW(), $4, NULL)
RETURNING session_id
`

type CreateTableSessionParams struct {
	ID             int64            `json:"id"`
	TableID        int64            `json:"table_id"`
	NumberOfPeople int32            `json:"number_of_people"`
	ExpireAt       pgtype.Timestamp `json:"expire_at"`
}

func (q *Queries) CreateTableSession(ctx context.Context, arg CreateTableSessionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createTableSession,
		arg.ID,
		arg.TableID,
		arg.NumberOfPeople,
		arg.ExpireAt,
	)
	var session_id pgtype.UUID
	err := row.Scan(&session_id)
	return session_id, err
}

const getTableSession = `-- name: GetTableSession :one
SELECT ts.session_id::text as "sessionID",
       t.id::text          AS "tableID",
       t.table_number      as "tableNumber",
       ts.status           as "status",
       ts.started_at       as "startedAt",
       o.id                AS "orderID"
FROM public.table_session ts
         JOIN public.tables t ON t.id = ts.table_id
         LEFT JOIN public.orders o ON o.session_id = ts.session_id
WHERE ts.session_id = $1::uuid
`

type GetTableSessionRow struct {
	SessionID   string                 `json:"sessionID"`
	TableID     string                 `json:"tableID"`
	TableNumber int32                  `json:"tableNumber"`
	Status      NullTableSessionStatus `json:"status"`
	StartedAt   pgtype.Timestamp       `json:"startedAt"`
	OrderID     pgtype.Int8            `json:"orderID"`
}

func (q *Queries) GetTableSession(ctx context.Context, sessionid pgtype.UUID) (*GetTableSessionRow, error) {
	row := q.db.QueryRow(ctx, getTableSession, sessionid)
	var i GetTableSessionRow
	err := row.Scan(
		&i.SessionID,
		&i.TableID,
		&i.TableNumber,
		&i.Status,
		&i.StartedAt,
		&i.OrderID,
	)
	return &i, err
}

const isTableSessionActive = `-- name: IsTableSessionActive :one
SELECT COUNT(session_id) > 0
FROM public.table_session
WHERE session_id = $1::uuid
  AND status = 'active'
`

func (q *Queries) IsTableSessionActive(ctx context.Context, sessionid pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isTableSessionActive, sessionid)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isTableSessionExists = `-- name: IsTableSessionExists :one
SELECT COUNT(session_id) > 0
FROM public.table_session
WHERE session_id = $1::uuid
`

func (q *Queries) IsTableSessionExists(ctx context.Context, sessionid pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isTableSessionExists, sessionid)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
