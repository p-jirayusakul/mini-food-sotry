// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO public.orders
(id, session_id, table_id, status_id)
VALUES($1::bigint, $2::uuid, $3::bigint, (SELECT id FROM public.md_order_statuses WHERE code = 'CONFIRMED' LIMIT 1))
RETURNING id
`

type CreateOrderParams struct {
	ID        int64       `json:"id"`
	SessionID pgtype.UUID `json:"session_id"`
	TableID   int64       `json:"table_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.ID, arg.SessionID, arg.TableID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT o.id, o.session_id as "sessionID", o.table_id as "tableID", t.table_number as "tableNumber", t.table_number as "tableNumber", o.status_id as "statusID", mos.name as "statusName", mos.name_en as "statusNameEN"
FROM public.orders as o
JOIN public.md_order_statuses as mos ON o.status_id = mos.id
JOIN public.tables as t ON o.table_id = t.id
WHERE o.id = $1::bigint
`

type GetOrderByIDRow struct {
	ID            int64       `json:"id"`
	SessionID     pgtype.UUID `json:"sessionID"`
	TableID       int64       `json:"tableID"`
	TableNumber   int32       `json:"tableNumber"`
	TableNumber_2 int32       `json:"tableNumber_2"`
	StatusID      int64       `json:"statusID"`
	StatusName    string      `json:"statusName"`
	StatusNameEN  string      `json:"statusNameEN"`
}

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (*GetOrderByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.TableID,
		&i.TableNumber,
		&i.TableNumber_2,
		&i.StatusID,
		&i.StatusName,
		&i.StatusNameEN,
	)
	return &i, err
}

const getOrderWithItems = `-- name: GetOrderWithItems :many
SELECT o.id  AS "orderID",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at
FROM public.orders o
JOIN public.order_items oi ON oi.order_id = o.id
JOIN public.md_order_statuses mos ON oi.status_id = mos.id
WHERE o.id = $1::bigint
order by oi.created_at DESC
`

type GetOrderWithItemsRow struct {
	OrderID       int64            `json:"orderID"`
	ID            int64            `json:"id"`
	ProductID     int64            `json:"productID"`
	ProductName   string           `json:"productName"`
	ProductNameEN string           `json:"productNameEN"`
	Quantity      int32            `json:"quantity"`
	Price         pgtype.Numeric   `json:"price"`
	StatusID      int64            `json:"statusID"`
	StatusName    string           `json:"statusName"`
	StatusNameEN  string           `json:"statusNameEN"`
	StatusCode    string           `json:"statusCode"`
	Note          pgtype.Text      `json:"note"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetOrderWithItems(ctx context.Context, orderID int64) ([]*GetOrderWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderWithItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrderWithItemsRow{}
	for rows.Next() {
		var i GetOrderWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductNameEN,
			&i.Quantity,
			&i.Price,
			&i.StatusID,
			&i.StatusName,
			&i.StatusNameEN,
			&i.StatusCode,
			&i.Note,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItemsByID = `-- name: GetOrderWithItemsByID :one
SELECT o.id  AS "orderID",
       oi.id AS "id",
       oi.product_id as "productID",
       oi.product_name as "productName",
       oi.product_name_en as "productNameEN",
       oi.quantity,
       (oi.price * oi.quantity) as "price",
       oi.status_id as "statusID",
       mos.name as "statusName",
       mos.name_en as "statusNameEN",
       mos.code as "statusCode",
       oi.note as "note",
       oi.created_at
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
         JOIN public.md_order_statuses mos ON oi.status_id = mos.id
WHERE o.id = $1::bigint AND oi.id = $2::bigint LIMIT 1
`

type GetOrderWithItemsByIDParams struct {
	OrderID      int64 `json:"order_id"`
	OrderItemsID int64 `json:"order_items_id"`
}

type GetOrderWithItemsByIDRow struct {
	OrderID       int64            `json:"orderID"`
	ID            int64            `json:"id"`
	ProductID     int64            `json:"productID"`
	ProductName   string           `json:"productName"`
	ProductNameEN string           `json:"productNameEN"`
	Quantity      int32            `json:"quantity"`
	Price         pgtype.Numeric   `json:"price"`
	StatusID      int64            `json:"statusID"`
	StatusName    string           `json:"statusName"`
	StatusNameEN  string           `json:"statusNameEN"`
	StatusCode    string           `json:"statusCode"`
	Note          pgtype.Text      `json:"note"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetOrderWithItemsByID(ctx context.Context, arg GetOrderWithItemsByIDParams) (*GetOrderWithItemsByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithItemsByID, arg.OrderID, arg.OrderItemsID)
	var i GetOrderWithItemsByIDRow
	err := row.Scan(
		&i.OrderID,
		&i.ID,
		&i.ProductID,
		&i.ProductName,
		&i.ProductNameEN,
		&i.Quantity,
		&i.Price,
		&i.StatusID,
		&i.StatusName,
		&i.StatusNameEN,
		&i.StatusCode,
		&i.Note,
		&i.CreatedAt,
	)
	return &i, err
}

const isOrderExist = `-- name: IsOrderExist :one
SELECT COUNT(id) > 0
FROM public.orders WHERE id = $1
`

func (q *Queries) IsOrderExist(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, isOrderExist, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isOrderWithItemsExists = `-- name: IsOrderWithItemsExists :one
SELECT COUNT(*) > 0
FROM public.orders o
         JOIN public.order_items oi ON oi.order_id = o.id
WHERE o.id = $1::bigint AND oi.id = $2::bigint LIMIT 1
`

type IsOrderWithItemsExistsParams struct {
	OrderID      int64 `json:"order_id"`
	OrderItemsID int64 `json:"order_items_id"`
}

func (q *Queries) IsOrderWithItemsExists(ctx context.Context, arg IsOrderWithItemsExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOrderWithItemsExists, arg.OrderID, arg.OrderItemsID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE public.orders
SET status_id = (SELECT id FROM public.md_order_statuses WHERE code = $1::text LIMIT 1)
WHERE id = $2::bigint
`

type UpdateOrderStatusParams struct {
	StatusCode string `json:"status_code"`
	ID         int64  `json:"id"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.StatusCode, arg.ID)
	return err
}
